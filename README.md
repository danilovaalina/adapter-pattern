# Паттерн проектирования «Адаптер» на Go

Этот пример демонстрирует реализацию паттерна проектирования **Адаптер** на языке Go. Паттерн позволяет совместить несовместимые интерфейсы, не изменяя существующий код.

## Структура проекта

```
adapter-pattern-go/
├── main.go          # Реализация паттерна Адаптер
└── README.md        # Документация
```

## Суть примера

В системе присутствуют две сущности:

- **`LegacyPaymentService`** - устаревший сервис оплаты, который принимает данные в виде строки формата `"сумма|валюта"`.
- **`PaymentProcessor`** - новый интерфейс, ожидаемый клиентским кодом, с методом `ProcessPayment(amount float64, currency string)`.

Поскольку изменять `LegacyPaymentService` нельзя (например, он принадлежит сторонней библиотеке), мы создаём **`PaymentAdapter`** - адаптер, который реализует интерфейс `PaymentProcessor`, но внутри преобразует вызовы к формату, понятному `LegacyPaymentService`.

Таким образом, новый клиентский код может работать со старым сервисом без изменений последнего.

## Применимость паттерна «Адаптер»

Паттерн полезен в следующих ситуациях:

- Вы используете **стороннюю библиотеку или устаревший код**, интерфейс которого не соответствует вашим ожиданиям.
- Вы **рефакторите систему** по частям и хотите временно сохранить совместимость между старыми и новыми компонентами.
- Вы пишете **обёртки вокруг API**, поверх различных внешних сервисов (например, разных платёжных провайдеров).
- Вы пишете **тестовые заглушки (mocks)**, которые должны соответствовать определённому интерфейсу.

## Преимущества

- **Совместимость без изменения исходного кода** - особенно важно при работе с закрытыми или сторонними библиотеками.
- **Соблюдение принципа открытости/закрытости (OCP)**: система открыта для расширения, но закрыта для модификации.
- **Разделение ответственности**: адаптер отвечает только за преобразование интерфейса.
- **Упрощает интеграцию** различных систем.

## Недостатки

- Может усложнить архитектуру, если использовать без необходимости.
- Дополнительный уровень абстракции - небольшой оверхед и сложность отладки.
- Не решает проблемы, если различия между интерфейсами **семантические**, а не только синтаксические (т.е два компонента по смыслу делают разные вещи, даже если их методы выглядят похоже).

## Реальные примеры использования

- **Интеграция сторонних API** (платёжных систем, SMS-шлюзов и т.п.)
- **Интеграция с легаси-системами** (например, адаптация банковского протокола ISO 8583 к современному REST API)
- **Стандартная библиотека Go**: например, `strings.Reader` адаптирует строку к интерфейсу `io.Reader`, а `bytes.Buffer` к `io.ReadWriter`.
